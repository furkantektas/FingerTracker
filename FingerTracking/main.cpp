#include <opencv2/opencv.hpp>
#include <opencv2/highgui/highgui.hpp>
#include <opencv2/imgproc/imgproc.hpp>
#include <opencv2/video/background_segm.hpp>
#include <iostream>

#define PI 3.141592653589793238463

using namespace cv;
using namespace std;

Mat frame,rawFrame;
Mat fgMaskMOG; //fg mask fg mask generated by MOG2 method
Ptr<BackgroundSubtractor> pMOG; //MOG2 Background subtractor

Mat findConvexHull(Mat img);
void drawConvexity(Mat drawing, vector<Vec4i> convDefect, vector<Point> contours);


float pointDistance(Point a, Point b);

float getAngle(Point s, Point f, Point e);
void filterConvexes(vector<Vec4i> convDefect, vector<Point> contours, Rect boundingRect);
    
bool isHand(vector<Point> contours, vector<Vec4i> convDefect);
void putTextWrapper(Mat img, char* text);
void printFingerCount(Mat img, int fingerCount);

int main(int argc, char** argv) {
    VideoCapture cap("/Users/ft/Development/FingerTracking/FingerTracking/hand.mov"); // open the default camera
    
    if(!cap.isOpened()) // check if we succeeded
        return -1;
    
    
    
    //create GUI windows
    namedWindow("Raw Frame");
    namedWindow("Thresholded Frame");
    namedWindow("FG Mask MOG");
    
    //create Background Subtractor objects
    pMOG = new BackgroundSubtractorMOG; //MOG2 approach


    for(int keyboard=0;keyboard!=27;keyboard = waitKey(30)) {
        cap >> rawFrame;
        //update the background model
        
        //get the frame number and write it on the current frame

        cvtColor(rawFrame, frame, COLOR_RGB2GRAY);
        pMOG->operator()(frame, frame);

        GaussianBlur(frame, frame, Size(5,5), 0);
        threshold(frame,frame,0,255,THRESH_BINARY + THRESH_OTSU);
//        adaptiveThreshold(frame,frame,255,CV_ADAPTIVE_THRESH_GAUSSIAN_C, THRESH_BINARY_INV,5,5);
        medianBlur(frame, fgMaskMOG,11);
        
        fgMaskMOG = findConvexHull(fgMaskMOG);
        
        
        imshow("Raw Frame", rawFrame);
        imshow("Thresholded Frame", frame);
        imshow("FG Mask MOG", fgMaskMOG);
        frame.release();
        rawFrame.release();
        fgMaskMOG.release();
    }
    //delete capture object


 }


Mat findConvexHull(Mat img){
    vector<vector<Point> > contours;
    vector<Vec4i> hierarchy;
    
//    Canny( img, img, 127, 255, 3 );
    findContours( img, contours, hierarchy, CV_RETR_EXTERNAL, CV_CHAIN_APPROX_SIMPLE, Point(0, 0) );
    vector<vector<Point> >hull( contours.size() );
    vector<vector<int> >hullI( contours.size() );
    vector<vector<Vec4i>> convdefect(contours.size());
    vector<Rect> boundRect( contours.size() );
    
    // finding convex hull, bounding rectangle and convexity defect
    for( int i = 0; i < contours.size(); i++ ) {
        convexHull( Mat(contours[i]), hull[i], false);
        convexHull( Mat(contours[i]), hullI[i], false);
        boundRect[i] = boundingRect(contours[i]);
        if (contours[i].size() >3 ) {
            convexityDefects(contours[i], hullI[i], convdefect[i]);
            filterConvexes(convdefect[i], contours[i], boundRect[i]);
        }
        
    }
    
    Mat drawing = Mat::zeros( img.size(), CV_8UC3 );
    
    const Scalar green(0,255,0);
    const Scalar red(255,0,0);
    const Scalar blue(0,0,255);

    // drawing convex hull, bounding rectangle and convexity defect
    for( int i = 0; i < contours.size(); i++ ) {
        if(convdefect[i].size()>6) {
            
        drawContours( drawing, hull, i, green, 3, 8, vector<Vec4i>(), 0, Point() );
        rectangle( drawing, boundRect[i].tl(), boundRect[i].br(), red, 2, 8, 0 );
//        circle( drawing, center[i], (int)radius[i], blue, 2, 8, 0 );
        drawConvexity(drawing, convdefect[i], contours[i]);
            printFingerCount(drawing, (int) convdefect[i].size());
        }
        cout << "BRect " << boundRect[i].width<<"x"<<boundRect[i].height<<endl;
    }
    
    return drawing;
}

float pointDistance(Point a, Point b){
    int dx = a.x - b.x;
    int dy = a.y - b.y;
    return sqrt(dx*dx + dy*dy);
}

float getAngle(Point p1, Point p2, Point p3){
    return abs(p1.y-p2.y)/sqrt((p1.x-p2.x)*(p1.x-p2.x)+(p1.y-p2.y)*(p1.y-p2.y)) * 180 / CV_PI;
}

void filterConvexes(vector<Vec4i> convDefect, vector<Point> contours, Rect boundingRect) {
    int tolerance =  boundingRect.height/5;
    float angleTol=30;
    vector<Vec4i>::iterator d=convDefect.begin();
    while( d!=convDefect.end() ) {
        Vec4i& v=(*d);
        int startidx=v[0]; Point ptStart( contours[startidx] );
        int endidx=v[1]; Point ptEnd( contours[endidx] );
        int faridx=v[2]; Point ptFar( contours[faridx] );
        cout << "ptstart:" << ptStart << "ptfar:"<< ptFar<< "ptend" << ptEnd << "distsf:" << pointDistance(ptStart, ptFar) << pointDistance(ptFar, ptEnd) << "angle " << getAngle(ptStart, ptFar, ptEnd  ) << endl;
        if(pointDistance(ptStart, ptFar) < tolerance ||
           pointDistance(ptEnd, ptFar) < tolerance ||
           getAngle(ptStart, ptFar, ptEnd  ) < angleTol ||
           pointPolygonTest(contours, ptFar, false) < 0.1f){
            d = convDefect.erase(d);
        } else
            d++;
    }

}

void putTextWrapper(Mat img, char* text) {
    static const int fontFace = FONT_HERSHEY_SCRIPT_SIMPLEX;
    static const double fontScale = 2;
    static const int thickness = 3;
    static const cv::Point textOrg(10, 130);
    cv::putText(img, text, textOrg, fontFace, fontScale, Scalar::all(255), thickness,8);
}

void printFingerCount(Mat img, int fingerCount) {
    char c[255];
    sprintf(c,"Finger #%d", fingerCount);
    putTextWrapper(img, c);
}

bool isHand(vector<Point> contours, vector<Vec4i> convDefect) {
    bool isHand = false;
    int concavity = 0;
    vector<Vec4i>::iterator d=convDefect.begin();
    while( d!=convDefect.end() ) {
        Vec4i& v=(*d);
        if(v[2]>100)
            ++concavity;
//        double pos = pointPolygonTest(contours, v, false);
//        if(pos)
        d++;
    }
    return true;
//    return (concavity > 2);
}

void drawConvexity(Mat drawing, vector<Vec4i> convDefect, vector<Point> contours) {
    vector<Vec4i>::iterator d=convDefect.begin();
    while( d!=convDefect.end() ) {
        Vec4i& v=(*d);
        int startidx=v[0]; Point ptStart( contours[startidx] );
        int endidx=v[1]; Point ptEnd( contours[endidx] );
        int faridx=v[2]; Point ptFar( contours[faridx] );
        float depth = v[3] / 256;
        
        if(v[2] > 100) {
        line( drawing, ptStart, ptFar, Scalar(255,255,255), 1 );
        line( drawing, ptEnd, ptFar, Scalar(255,0,255), 1 );
        circle( drawing, ptFar, 4, Scalar(255,0,0), 4 );
        }
        d++;
    }
}