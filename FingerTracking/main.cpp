#include <opencv2/opencv.hpp>
#include <opencv2/highgui/highgui.hpp>
#include <opencv2/imgproc/imgproc.hpp>
#include <opencv2/video/background_segm.hpp>
#include <iostream>

using namespace cv;
using namespace std;

Mat thresh_frame,rawFrame;
Mat fgMaskMOG; //fg mask fg mask generated by MOG2 method
Ptr<BackgroundSubtractor> pMOG; //MOG2 Background subtractor

Mat findConvexHull(Mat& img);

void process_frame(Mat& frame);
void drawConvexity(Mat& drawing, vector<Vec4i>& convDefect, vector<Point>& contours);

std::string getImageType(int number);

float pointDistance(Point& a, Point& b);
int findLargestContour(vector<vector<Point>>& contours);
float getAngle(Point& s, Point& f, Point& e);
void filterConvexes(vector<Vec4i>& convDefect, vector<Point>& contours, Rect& boundingRect);
    
bool isHand(vector<Point>& contours, vector<Vec4i>& convDefect);
void putTextWrapper(Mat& img, char* text);
void printFingerCount(Mat& img, int fingerCount);

int main(int argc, char** argv) {
    VideoCapture cap("/Users/ft/Development/FingerTracking/FingerTracking/hand.m4v");
    if(!cap.isOpened()) // check if we succeeded
        return -1;
    
    //create GUI windows
    namedWindow("Raw Frame");
    namedWindow("Thresholded Frame");
    namedWindow("FG Mask MOG");
    
    //create Background Subtractor objects
    pMOG = new BackgroundSubtractorMOG; //MOG2 approach


    for(int keyboard=0;keyboard!=27 && cap.grab();keyboard = waitKey(300)) {
        cap >> rawFrame;
        
        thresh_frame = rawFrame.clone();
        process_frame(thresh_frame);
        
        fgMaskMOG = thresh_frame.clone();
        fgMaskMOG = findConvexHull(fgMaskMOG);
        
        
        imshow("Raw Frame", rawFrame);
        imshow("Thresholded Frame", thresh_frame);
        imshow("FG Mask MOG", fgMaskMOG);
    }
    
    thresh_frame.release();
    rawFrame.release();
    fgMaskMOG.release();
    
    //delete capture object


 }

void process_frame(Mat& frame) {
    cvtColor(frame, frame, COLOR_RGB2GRAY);
    //        pMOG->operator()(frame, frame);
    
    //        GaussianBlur(frame, frame, Size(3,3), 0);
    
    threshold(frame,frame,0,255,THRESH_BINARY + THRESH_OTSU);
    
    int erosion_size = 1;
    Mat element = getStructuringElement(cv::MORPH_ELLIPSE,
                                        cv::Size(2 * erosion_size + 1, 2 * erosion_size + 1),
                                        cv::Point(erosion_size, erosion_size) );
    dilate(frame, frame, element);
    dilate(frame, frame, element);
    //        adaptiveThreshold(frame,frame,255,CV_ADAPTIVE_THRESH_GAUSSIAN_C, THRESH_BINARY,5,5);
    //        medianBlur(frame, fgMaskMOG,11);
}

Mat findConvexHull(Mat& img){
    vector<vector<Point> > contours;
    vector<Vec4i> hierarchy;

    findContours( img, contours, hierarchy, CV_RETR_EXTERNAL, CV_CHAIN_APPROX_SIMPLE, Point(0,0) );
    vector<vector<Point> >hull( contours.size() );
    vector<vector<int> >hullI( contours.size() );
    vector<vector<Vec4i>> convdefect(contours.size());
    vector<Rect> boundRect( contours.size() );
    
    // finding convex hull, bounding rectangle and convexity defect
    for( int i = 0; i < contours.size(); i++ ) {
        convexHull( Mat(contours[i]), hull[i], false);
        convexHull( Mat(contours[i]), hullI[i], false);
        boundRect[i] = boundingRect(contours[i]);
        if (contours[i].size() >3 ) {
            convexityDefects(contours[i], hullI[i], convdefect[i]);
            filterConvexes(convdefect[i], contours[i], boundRect[i]);
        }
    }
    
    Mat drawing = Mat::zeros( img.size(), CV_8UC3 );
    
    const Scalar green(0,255,0);
    const Scalar red(255,0,0);
    const Scalar blue(0,0,255);

    int handInd = findLargestContour(contours);
    Rect handRect = boundingRect(contours[handInd]);

    
    // drawing convex hull, bounding rectangle and convexity defect
//    for( int i = 0; i < contours.size(); i++ ) {
//        if(convdefect[i].size()>6) {
//            
//        drawContours( drawing, hull, i, green, 3, 8, vector<Vec4i>(), 0, Point() );
//        rectangle( drawing, boundRect[i].tl(), boundRect[i].br(), red, 2, 8, 0 );
////        circle( drawing, center[i], (int)radius[i], blue, 2, 8, 0 );
//        drawConvexity(drawing, convdefect[i], contours[i]);
//            printFingerCount(drawing, (int) convdefect[i].size());
//        }
//        cout << "BRect " << boundRect[i].width<<"x"<<boundRect[i].height<<endl;
//    }
    drawContours(drawing, hull, handInd, red,3,8,vector<Vec4i>(),0,Point());
    rectangle(drawing, handRect.tl(), handRect.br(), green,2,8,0);
    
    return drawing;
}

float pointDistance(Point& a, Point& b){
    int dx = a.x - b.x;
    int dy = a.y - b.y;
    return sqrt(dx*dx + dy*dy);
}

float getAngle(Point& p1, Point& p2, Point& p3){
    return abs(p1.y-p2.y)/sqrt((p1.x-p2.x)*(p1.x-p2.x)+(p1.y-p2.y)*(p1.y-p2.y)) * 180 / CV_PI;
}

int findLargestContour(vector<vector<Point>>& contours) {
    int largest_contour_index = -1;
    double largest_area=0;
    for( int i = 0; i< contours.size(); i++ ) {
        //  Find the area of contour
        double a=contourArea( contours[i],false);
        if(a>largest_area){
            largest_area=a;
            //cout<<i<<" area  "<<a<<endl;
            // Store the index of largest contour
            largest_contour_index=i;
            // Find the bounding rectangle for biggest contour
//            bounding_rect=boundingRect(contours[i]);
        }
    }
    return largest_contour_index;
}

void filterConvexes(vector<Vec4i>& convDefect, vector<Point>& contours, Rect& boundingRect) {
    int tolerance =  boundingRect.height/5;
    float angleTol=30;
    vector<Vec4i>::iterator d=convDefect.begin();
    while( d!=convDefect.end() ) {
        Vec4i& v=(*d);
        int startidx=v[0]; Point ptStart( contours[startidx] );
        int endidx=v[1]; Point ptEnd( contours[endidx] );
        int faridx=v[2]; Point ptFar( contours[faridx] );
        cout << "ptstart:" << ptStart << "\tptfar:"<< ptFar<< " \tptend" << ptEnd << "\tdistsf:" << pointDistance(ptStart, ptFar) << pointDistance(ptFar, ptEnd) << "\tangle " << getAngle(ptStart, ptFar, ptEnd  ) << endl;
        if(pointDistance(ptStart, ptFar) < tolerance ||
           pointDistance(ptEnd, ptFar) < tolerance ||
           getAngle(ptStart, ptFar, ptEnd  ) < angleTol ||
           pointPolygonTest(contours, ptFar, false) < 0.1f){
            d = convDefect.erase(d);
        } else
            d++;
    }

}

void putTextWrapper(Mat& img, char* text) {
    static const int fontFace = FONT_HERSHEY_SCRIPT_SIMPLEX;
    static const double fontScale = 2;
    static const int thickness = 3;
    static const cv::Point textOrg(10, 130);
    cv::putText(img, text, textOrg, fontFace, fontScale, Scalar::all(255), thickness,8);
}

void printFingerCount(Mat& img, int fingerCount) {
    char c[255];
    sprintf(c,"Finger #%d", fingerCount);
    putTextWrapper(img, c);
}

bool isHand(vector<Point>& contours, vector<Vec4i>& convDefect) {
    bool isHand = false;
    int concavity = 0;
    vector<Vec4i>::iterator d=convDefect.begin();
    while( d!=convDefect.end() ) {
        Vec4i& v=(*d);
        if(v[2]>100)
            ++concavity;
//        double pos = pointPolygonTest(contours, v, false);
//        if(pos)
        d++;
    }
    return true;
//    return (concavity > 2);
}

void drawConvexity(Mat& drawing, vector<Vec4i>& convDefect, vector<Point>& contours) {
    vector<Vec4i>::iterator d=convDefect.begin();
    while( d!=convDefect.end() ) {
        Vec4i& v=(*d);
        int startidx=v[0]; Point ptStart( contours[startidx] );
        int endidx=v[1]; Point ptEnd( contours[endidx] );
        int faridx=v[2]; Point ptFar( contours[faridx] );
        float depth = v[3] / 256;
        
        if(v[2] > 100) {
        line( drawing, ptStart, ptFar, Scalar(255,255,255), 1 );
        line( drawing, ptEnd, ptFar, Scalar(255,0,255), 1 );
        circle( drawing, ptFar, 4, Scalar(255,0,0), 4 );
        }
        d++;
    }
}


std::string getImageType(int number)
{
    // find type
    int imgTypeInt = number%8;
    std::string imgTypeString;
    
    switch (imgTypeInt)
    {
        case 0:
            imgTypeString = "8U";
            break;
        case 1:
            imgTypeString = "8S";
            break;
        case 2:
            imgTypeString = "16U";
            break;
        case 3:
            imgTypeString = "16S";
            break;
        case 4:
            imgTypeString = "32S";
            break;
        case 5:
            imgTypeString = "32F";
            break;
        case 6:
            imgTypeString = "64F";
            break;
        default:
            break;
    }
    
    // find channel
    int channel = (number/8) + 1;
    
    std::stringstream type;
    type<<"CV_"<<imgTypeString<<"C"<<channel;
    
    return type.str();
}